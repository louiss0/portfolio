import {
  __commonJS
} from "./chunk-Y2F7D3TJ.js";

// node_modules/.pnpm/clsx@2.0.0/node_modules/clsx/dist/clsx.js
var require_clsx = __commonJS({
  "node_modules/.pnpm/clsx@2.0.0/node_modules/clsx/dist/clsx.js"(exports, module) {
    function e(r2) {
      var o, t, f = "";
      if ("string" == typeof r2 || "number" == typeof r2)
        f += r2;
      else if ("object" == typeof r2)
        if (Array.isArray(r2))
          for (o = 0; o < r2.length; o++)
            r2[o] && (t = e(r2[o])) && (f && (f += " "), f += t);
        else
          for (o in r2)
            r2[o] && (f && (f += " "), f += o);
      return f;
    }
    function r() {
      for (var r2, o, t = 0, f = ""; t < arguments.length; )
        (r2 = arguments[t++]) && (o = e(r2)) && (f && (f += " "), f += o);
      return f;
    }
    module.exports = r, module.exports.clsx = r;
  }
});

// node_modules/.pnpm/@code-fixer-23+cn-efs@2.2.4/node_modules/@code-fixer-23/cn-efs/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/@code-fixer-23+cn-efs@2.2.4/node_modules/@code-fixer-23/cn-efs/dist/index.js"(exports, module) {
    var ee = Object.create;
    var x = Object.defineProperty;
    var te = Object.getOwnPropertyDescriptor;
    var se = Object.getOwnPropertyNames;
    var ae = Object.getPrototypeOf;
    var re = Object.prototype.hasOwnProperty;
    var ne = (e, a) => {
      for (var i in a)
        x(e, i, { get: a[i], enumerable: true });
    };
    var j = (e, a, i, s) => {
      if (a && typeof a == "object" || typeof a == "function")
        for (let t of se(a))
          !re.call(e, t) && t !== i && x(e, t, { get: () => a[t], enumerable: !(s = te(a, t)) || s.enumerable });
      return e;
    };
    var ie = (e, a, i) => (i = e != null ? ee(ae(e)) : {}, j(a || !e || !e.__esModule ? x(i, "default", { value: e, enumerable: true }) : i, e));
    var oe = (e) => j(x({}, "__esModule", { value: true }), e);
    var Pe = {};
    ne(Pe, { bootstrapCN_EFS: () => De, cnEFS: () => ke, tailwindOrWindiCN_EFS: () => je });
    module.exports = oe(Pe);
    var Z = ie(require_clsx());
    var U = /^(?<variable_hint>[a-z]+:)?(?<variable_value>--_?[a-z0-9]+(?:(?:-|_)[a-z0-9]+)*)$/;
    var le = (e) => U.test(e);
    var ue = (e) => {
      var _a, _b;
      return ((_b = (_a = U.exec(e)) == null ? void 0 : _a.groups) == null ? void 0 : _b.variable_hint) === "color:";
    };
    var pe = (e) => {
      var _a, _b;
      return ((_b = (_a = U.exec(e)) == null ? void 0 : _a.groups) == null ? void 0 : _b.variable_hint) === "length:";
    };
    var de = (e) => {
      var _a, _b;
      return ((_b = (_a = U.exec(e)) == null ? void 0 : _a.groups) == null ? void 0 : _b.variable_hint) === "string:";
    };
    var ce = /^(?<variant>\S+:)?(?<prefix>!|-|!-)?(?<type>[a-z]+-)(?<subtype>(?<first>[a-z]+-)?(?<second>[a-z]+-))?(?<value>\[[\w\-0-9$.#),(%\/:]+\]|[\w\d\/\][]+)$/;
    var ye = /^(?<type>[a-z]+|[a-z]+-[a-z]+)(?<breakpoint>-(?:sm|md|lg|xl|xxl))?-(?<value>[a-z0-9]+)(?<state>-[a-z]+)?$/;
    var fe = /^(?<type>[a-z]+|[a-z]+-[a-z]+)(?<breakpoint>-(?:sm|md|lg|xl|xxl))?-(?<value>(?:(?:(?:prim|second|terti)ary)|info|light|dark|danger|warning)+(?:-emphasis|-subtle)?)(?<state>-[a-z]+)?$/;
    var Ce = /^(?<digit>\d{1,4}(?:[a-z]{2,4})?)$/;
    var O = (e) => Ce.test(e);
    var F = /^(?<color>[a-z]+-)(?<range>[0-9]{2,4})$/;
    var ge = /^(?<hex_color>#[A-Fa-f0-9]{3,6})$/;
    var P = /(?<css_color_function>[a-z]{3,9}\((?:\d{1,4}(?:%|[a-z]{3,4}|\.\d+)?(?:,|_)?){3,4}\))/;
    var Te = /(?<variant>\S+:)?(?<class_type_and_value>[a-z0-9\-_\]\[,)(%#!]+)/;
    var K = (e) => F.test(e);
    var G = /^(?<subtype>[a-z]+ary-)(?<value>[a-z\d]+)?$/;
    var he = (e) => ge.test(e) || P.test(e) || G.test(e);
    var me = /^(?<css_function>[a-z_-]{3,15}\(([a-z0-9%!\(\).\/-]+(?:_|,)?)+\))$/;
    var Se = (e) => me.test(e) && !P.test(e);
    var be = /^\[(?<value>[\w\-),%!\/($.:#]+)\]$/;
    var Ae = /^(?<lower_case_word>[a-z]+)$/;
    var we = /(?<first_word>[a-z]+-)(?<middle_words>(?:[a-z]+-)+)?(?<last_word>[a-z]+)/;
    var z = (e) => Ae.test(e);
    var ve = /([a-z0-9\-)(\/,.]+)(?:_[a-z0-9\/),(.\-]+)+/;
    var Me = (e) => ve.test(e);
    var c = ["digit", "word", "color", "variable", "function", "args", "slashValue"];
    var B = (e) => {
      let a = { customFiltered: /* @__PURE__ */ new Map(), safeListed: [] };
      return Object.freeze(e ? Object.assign(a, e) : a);
    };
    var Ie = () => B({ bem: /* @__PURE__ */ new Map() });
    var L = () => Object.freeze({ ...Ie(), basicUtility: /* @__PURE__ */ new Map() });
    var H = () => B({ bootstrapCSSUtility: /* @__PURE__ */ new Map() });
    var q = () => B({ arbitraryProperties: /* @__PURE__ */ new Map(), tailwindCSSUtility: /* @__PURE__ */ new Map() });
    var Y = (e, a) => {
      var _a, _b, _c, _d, _e2;
      let i = ((_a = /(?<type>[a-z]+-)(?<subtype>(?:[a-z]+-)*)?(?<value>[a-z\d]+)/.exec(a)) == null ? void 0 : _a.groups) || ((_b = /(?<type>[a-z]+)(?<value>\d+)/.exec(a)) == null ? void 0 : _b.groups);
      if (!i)
        return false;
      let { type: s, value: t, subtype: r = "" } = i;
      if (!s || !t)
        return false;
      let l = `${s}${r}`, n = `${r}${t}`, o = O(t), y = z(t), u = K(n) || G.test(n), p = (_c = F.exec(n)) == null ? void 0 : _c.groups, b = (_d = we.exec(n)) == null ? void 0 : _d.groups;
      if (!e.has(s)) {
        if (u) {
          if (p) {
            let { color: d, range: g } = p;
            return !d || !g ? false : (e.set(s, /* @__PURE__ */ new Map([[c[2], `${d}${g}`]])), true);
          }
          return e.set(s, /* @__PURE__ */ new Map([[c[2], n]])), true;
        }
        if (o)
          return e.set(l, /* @__PURE__ */ new Map([[c[0], t]])), true;
        if (y) {
          if (b) {
            let { first_word: d, middle_words: g = "", last_word: T } = b;
            return d && T ? (e.set(s, /* @__PURE__ */ new Map([[c[1], `${d}${g}${T}`]])), true) : ((_e2 = e.get(s)) == null ? void 0 : _e2.set(c[1], `${d}${g}${T}`), true);
          }
          return e.set(l, /* @__PURE__ */ new Map([[c[1], t]])), true;
        }
      }
      let f = e.get(s) || e.get(l);
      if (f) {
        if (u)
          return p ? (f.set(c[2], `${p.color}${p.range}`), true) : (f.set(c[2], t), true);
        if (o)
          return f.set(c[0], t), true;
        if (y)
          return f.set(c[1], t), true;
      }
      return false;
    };
    var J = (e, a) => {
      var _a, _b, _c, _d;
      let i = ((_a = fe.exec(a)) == null ? void 0 : _a.groups) || ((_b = ye.exec(a)) == null ? void 0 : _b.groups);
      if (!i)
        return false;
      let { type: s, value: t, breakpoint: r = "", state: l = "base" } = i;
      if (!s || !t)
        return false;
      let n = `${s}${r}`, o = O(t), y = /[a-z\-_]+/.test(t);
      if (!e.has(n)) {
        if (o)
          return e.set(n, /* @__PURE__ */ new Map([["digitMap", (/* @__PURE__ */ new Map()).set(l, t)]])), true;
        if (y)
          return e.set(n, /* @__PURE__ */ new Map([["wordMap", (/* @__PURE__ */ new Map()).set(l, t)]])), true;
      }
      let u = e.get(n);
      if (u) {
        if (o)
          return (_c = u.get("digitMap")) == null ? void 0 : _c.set(l, t), true;
        if (y)
          return (_d = u.get("wordMap")) == null ? void 0 : _d.set(l, t), true;
      }
      return false;
    };
    var Ve = (e, a) => (i, s, t) => {
      let { type: r, subtype: l } = t;
      if (!e.some((C) => r.startsWith(C) || r === C))
        return false;
      let o = (C, w) => {
        var _a, _b;
        return r.endsWith(C) ? (_a = i.get(`${r.replace(C, "")}${w}`)) == null ? void 0 : _a.delete(s) : l === C ? (_b = i.get(`${r}${w === "-" ? "" : w}`)) == null ? void 0 : _b.delete(s) : false;
      }, { up: y, down: u, left: p, right: b, horizontal: f, both: d, vertical: g, bottomLeft: T, bottomRight: h, topLeft: A, topRight: m } = a;
      return [o(d, y), o(y, d), o(u, d), o(p.primary, d), o(d, p.primary), o(b.primary, d), o(d, b.primary), o(A.primary, d), o(d, A.primary), o(m.primary, d), o(d, m.primary), o(T.primary, d), o(d, T.primary), o(h.primary, d), o(d, h.primary), o(f, d), o(d, f), o(g, d), o(d, g), (p == null ? void 0 : p.secondary) && (b == null ? void 0 : b.secondary) && o(p.secondary, d), (p == null ? void 0 : p.secondary) && (b == null ? void 0 : b.secondary) && o(d, p.secondary), (A == null ? void 0 : A.secondary) && (m == null ? void 0 : m.secondary) && o(m.secondary, d), (A == null ? void 0 : A.secondary) && (m == null ? void 0 : m.secondary) && o(d, m.secondary), (T == null ? void 0 : T.secondary) && (h == null ? void 0 : h.secondary) && o(h.secondary, d), (T == null ? void 0 : T.secondary) && (h == null ? void 0 : h.secondary) && o(d, h.secondary)].reduce((C) => C === true);
    };
    var $e = ["m", "z-index", "border", "p", "start", "end", "overflow", "gap", "scale", "translate", "rotate", "skew", "rounded", "scroll", "scroll-m", "touch-pan", "bg-repeat", "divide"];
    var $ = Ve($e, { up: "t-", down: "b-", left: { primary: "l-", secondary: "s-" }, topLeft: { primary: "tl-", secondary: "ss-" }, bottomLeft: { primary: "bl-", secondary: "es-" }, right: { primary: "r-", secondary: "e-" }, topRight: { primary: "tr-", secondary: "se-" }, bottomRight: { primary: "br-", secondary: "ee-" }, horizontal: "x-", both: "-", vertical: "y-" });
    var D = (e, a) => {
      var _a, _b, _c, _d, _e2, _f, _g;
      let i = false, s = { text: { classType: "text-", valueType: "word", secondary: { classType: "leading-", valueType: "digit" } }, shadow: { classType: "shadow-", valueType: "color", secondary: { classType: "opacity-", valueType: "digit" } }, accent: { classType: "accent-", valueType: "color", secondary: { classType: "opacity-", valueType: "digit" } }, bg: { classType: "bg-", valueType: "color", secondary: { classType: "opacity-", valueType: "digit" } }, border: { isDirectional: true, classType: "border-", valueType: "color", secondary: { classType: "opacity-", valueType: "digit" } }, divide: { isDirectional: true, classType: "divide-", valueType: "color", secondary: { classType: "opacity-", valueType: "digit" } }, ring: { classType: "ring-", valueType: "color", secondary: { classType: "opacity-", valueType: "digit" } } }, { variant: t, prefix: r, type: l, firstSubtype: n, secondSubtype: o = "", value: y } = a, u = s[l.replace("-", "")], p = n ? `${t}${l}${n}` : `${t}${l}${o}`, b = /^[a-z\d]+\/[a-z\d\][]+$/.test(y);
      if (u && b) {
        let d = `${o}${y}`, g = /^[a-z]+-[a-z\d]+\/[a-z\d\][\.]+$/.test(d);
        if (n && g && (e.has(p) || e.set(p, /* @__PURE__ */ new Map([[c[6], /* @__PURE__ */ new Map([["prefix", r], ["value", d]])]])), e.has(p))) {
          let C = e.get(p);
          !(C == null ? void 0 : C.has(c[6])) && (C == null ? void 0 : C.set("slashValue", /* @__PURE__ */ new Map([["prefix", r], ["value", d]]))), (_b = (_a = C == null ? void 0 : C.get(c[6])) == null ? void 0 : _a.set("prefix", r)) == null ? void 0 : _b.set("value", d);
        }
        if (!n && (e.has(p) || e.set(p, /* @__PURE__ */ new Map([[c[6], /* @__PURE__ */ new Map([["prefix", r], ["value", y]])]])), e.has(p))) {
          let C = e.get(p);
          !(C == null ? void 0 : C.has(c[6])) && (C == null ? void 0 : C.set("slashValue", /* @__PURE__ */ new Map([["prefix", r], ["value", y]]))), (_d = (_c = C == null ? void 0 : C.get(c[6])) == null ? void 0 : _c.set("prefix", r)) == null ? void 0 : _d.set("value", y);
        }
        let { isDirectional: T, secondary: h, classType: A, valueType: m } = u;
        T && ($(e, "color", { type: `${t}${A}`, subtype: n ?? o }), (_e2 = e.get(`${t}${h.classType}`)) == null ? void 0 : _e2.delete(h.valueType)), T || ((_f = e.get(`${t}${A}`)) == null ? void 0 : _f.delete(m), (_g = e.get(`${t}${h.classType}`)) == null ? void 0 : _g.delete(h.valueType)), i = true;
      }
      return i;
    };
    var E = (e, a) => {
      var _a, _b, _c, _d, _e2;
      let i = (_a = ce.exec(a)) == null ? void 0 : _a.groups;
      if (!i)
        return false;
      let { type: s, value: t, variant: r = "", subtype: l = "", prefix: n = "", first: o, second: y } = i;
      if (!s || !t)
        return false;
      let u = `${r}${s}`, p = `${r}${s}${l}`, b = `${l}${t}`, f = (_b = t.match(be)) == null ? void 0 : _b[1], d = !!f, g = O(t) || f && O(f) || f && pe(f), T = z(t) || d && z(f) || d && de(f), h = d && Se(f), A = d && Me(f), m = d && le(f), C = f && he(f) || d && ue(f) || K(`${l}${t}`);
      if (n === "-" && !g)
        throw new Error(`The ${n} only works with digits don't use it on classes that aren't numbers`);
      let w = (_c = F.exec(b)) == null ? void 0 : _c.groups;
      if (l) {
        if (w) {
          let { color: V, range: R } = w;
          return !V || !R ? false : e.has(u) ? ((_d = e.get(u)) == null ? void 0 : _d.set(c[2], /* @__PURE__ */ new Map([["prefix", n], ["value", `${V}${R}`]])), v(e, p, "color"), true) : (e.set(u, /* @__PURE__ */ new Map([[c[2], /* @__PURE__ */ new Map([["prefix", n], ["value", `${V}${R}`]])]])), true);
        }
        if (!e.has(p)) {
          if (g)
            return e.set(p, /* @__PURE__ */ new Map([[c[0], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])]])), $(e, "digit", { type: u, subtype: l }) || v(e, p, "digit"), true;
          if (T)
            return e.set(p, /* @__PURE__ */ new Map([[c[1], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])]])), v(e, p, "word"), true;
          if (h)
            return e.set(p, /* @__PURE__ */ new Map([[c[4], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])]])), v(e, p, "function"), true;
          if (m)
            return e.set(p, /* @__PURE__ */ new Map([[c[3], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])]])), v(e, p, "variable"), true;
          if (A)
            return e.set(p, /* @__PURE__ */ new Map([[c[5], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])]])), v(e, p, "args"), true;
        }
        let I = e.get(p);
        if (I) {
          if (g)
            return I.set(c[0], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])), $(e, "digit", { type: u, subtype: l }) || v(e, p, "digit"), true;
          if (T)
            return I.set(c[1], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])), v(e, p, "word"), true;
          if (h)
            return I.set(c[4], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])), v(e, p, "color"), true;
          if (m)
            return I.set(c[3], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])), v(e, p, "variable"), true;
          if (A)
            return I.set(c[5], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])), v(e, p, "args"), true;
        }
        return !!D(e, { type: s, firstSubtype: o, secondSubtype: y, value: t, variant: r, prefix: n });
      }
      if (!e.has(u)) {
        if (C)
          return e.set(u, /* @__PURE__ */ new Map([[c[2], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])]])), S(e, u, "color"), true;
        if (g)
          return e.set(p, /* @__PURE__ */ new Map([[c[0], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])]])), $(e, "digit", { type: u, subtype: l }) || S(e, u, "digit"), true;
        if (T)
          return e.set(p, /* @__PURE__ */ new Map([[c[1], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])]])), S(e, u, "word"), true;
        if (h)
          return e.set(p, /* @__PURE__ */ new Map([[c[4], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])]])), S(e, u, "function"), true;
        if (m)
          return e.set(p, /* @__PURE__ */ new Map([[c[3], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])]])), S(e, u, "variable"), true;
        if (A)
          return e.set(p, /* @__PURE__ */ new Map([[c[5], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])]])), S(e, u, "args"), true;
      }
      let M = e.get(u);
      if (M) {
        if (C)
          return w ? ((_e2 = M.get(c[2])) == null ? void 0 : _e2.set("prefix", n).set("value", `${w == null ? void 0 : w.color}${w == null ? void 0 : w.range}`), S(e, u, "color"), true) : (M.set(c[2], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])), S(e, u, "color"), true);
        if (g)
          return M.set(c[0], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])), $(e, "digit", { type: u, subtype: l }) || S(e, u, "digit"), true;
        if (T)
          return M.set(c[1], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])), S(e, u, "word"), true;
        if (h)
          return M.set(c[4], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])), S(e, u, "function"), true;
        if (m)
          return M.set(c[3], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])), S(e, u, "variable"), true;
        if (A)
          return M.set(c[5], /* @__PURE__ */ new Map([["prefix", n], ["value", t]])), S(e, u, "args"), true;
      }
      return !!D(e, { type: s, firstSubtype: o, secondSubtype: y, value: t, variant: r, prefix: n });
    };
    function v(e, a, i) {
      var _a, _b;
      let s = /^(?<variant>\S+:)?(?<type>[a-z]+-)(?<subtype>[a-z]+-)$/, t = (_a = s.exec(a)) == null ? void 0 : _a.groups;
      if (!t)
        return;
      let { variant: r = "", type: l } = t;
      if (!l)
        return;
      let n = Array.from(e.keys()).find((o) => {
        let y = s.test(o), u = new Set(`${o}${r}${l}`).size === new Set(o).size;
        return y && o !== a && u;
      });
      if (n)
        return (_b = e.get(n)) == null ? void 0 : _b.delete(i);
    }
    function S(e, a, i) {
      var _a, _b;
      let s = /^(?<variant>\S+:)(?<type>[a-z]+-)$/, t = (_a = s.exec(a)) == null ? void 0 : _a.groups;
      if (!t)
        return;
      let { variant: r, type: l } = t;
      if (!r || !l)
        return;
      let n = Array.from(e.keys()).find((o) => {
        let y = s.test(o), u = new Set(`${o}${r}${l}`).size === new Set(o).size;
        return y && o !== a && u;
      });
      if (n)
        return (_b = e.get(n)) == null ? void 0 : _b.delete(i);
    }
    var _ = (e, a, i) => {
      let s = false;
      return Object.entries(i).forEach(([t, r]) => {
        var _a, _b;
        let l = (_a = Te.exec(a)) == null ? void 0 : _a.groups;
        if (!l)
          return;
        let { variant: n = "base", class_type_and_value: o } = l;
        o && (!e.has(t) && r.includes(o) && (e.set(t, /* @__PURE__ */ new Map([[n, o]])), s = true), r.includes(o) && ((_b = e.get(t)) == null ? void 0 : _b.set(n, o), s = true));
      }), s;
    };
    var xe = /^(?<lower_case_word>[a-z]+)(?<element>__[a-z]+(?:--[a-z0-9]+)?)$/;
    var Oe = /^(?<lower_case_word>[a-z]+)(?<modifier>--[a-z0-9]+)$/;
    var Q = (e, a, i) => {
      var _a, _b, _c, _d;
      let s = (_a = xe.exec(a)) == null ? void 0 : _a.groups, t = (_b = Oe.exec(a)) == null ? void 0 : _b.groups;
      if (s) {
        let { lower_case_word: r, element: l } = s;
        return !r || !l ? false : e.has(r) ? ((_c = e.get(r)) == null ? void 0 : _c.set("element", l), true) : (e.set(r, /* @__PURE__ */ new Map([["element", l]])), true);
      }
      if (t) {
        let { lower_case_word: r, modifier: l } = t;
        if (!r || !l)
          return false;
        if (!i.includes(r))
          throw new Error(`To have a modifier you must have the block ${r} in the list of classes already.
                    Please put the block as the class that requires the use of the modifier.`);
        return e.has(r) ? ((_d = e.get(r)) == null ? void 0 : _d.set("modifier", l), true) : (e.set(r, /* @__PURE__ */ new Map([["modifier", l]])), true);
      }
      return false;
    };
    var Ue = /(?<variant>\S+:)?\[(?<property_key>[a-z]+(?:\-[a-z]+)*:)(?<property_value>[_\-),.\/(a-z0-9]+)\]/;
    var N = (e, a) => {
      var _a;
      let i = Ue.exec(a);
      if (!i)
        return false;
      let [, s = "base", t, r] = i;
      return !t || !r ? false : e.has(t) ? ((_a = e.get(t)) == null ? void 0 : _a.set(s, r), true) : (e.set(t, /* @__PURE__ */ new Map([[s, r]])), true);
    };
    var Re = /^(?<relationship>@?[a-z-]+\/)(?<name>[a-z]+)$/;
    var W = (e, a) => {
      var _a, _b;
      let i = a.match(Re);
      if (!i)
        return false;
      let [, s, t] = i;
      return !s || !t ? false : e.has(s) ? ((_b = (_a = e.get(s)) == null ? void 0 : _a.get("word")) == null ? void 0 : _b.set("value", t), true) : (e.set(s, /* @__PURE__ */ new Map([["word", /* @__PURE__ */ new Map([["value", t]])]])), true);
    };
    var ze = /(?<variant>\S+:)\((?<class_names>(?:[\w\-\]\[$.#),(%:\/]+)(?:\s[\w\-\]\[$.#)\/,(%:]+)+)\)/;
    var X = ({ arbitraryProperties: e, customFiltered: a, tailwindCSSUtility: i }, s, t) => {
      var _a;
      let r = false, l = (_a = ze.exec(s)) == null ? void 0 : _a.groups;
      if (!l)
        return r;
      let { variant: n, class_names: o } = l;
      return !n || !o || (o == null ? void 0 : o.split(/\s/)).map((u) => `${n}${u}`).forEach((u) => {
        if (E(i, u)) {
          r = true;
          return;
        }
        if (W(i, u)) {
          r = true;
          return;
        }
        if (N(e, u)) {
          r = true;
          return;
        }
        if (t && _(a, u, t)) {
          r = true;
          return;
        }
      }), r;
    };
    var Fe = (e) => {
      let a = "";
      if (e.size === 0)
        return a;
      for (let i of e.values())
        if (i)
          for (let [s, t] of i)
            a = a.concat(`${s === "base" ? "" : s}${t} `);
      return a;
    };
    var Be = (e) => e.length === 0 ? "" : `${e.join(" ")} `;
    var Ee = (e, a, i) => (s, t) => {
      let r = e(), { customFiltered: l, safeListed: n, ...o } = s.reduce(_e(t, a), r), y = Be(n), u = Fe(l);
      return i(o, y.concat(u)).trimEnd();
    };
    function _e(e, a) {
      return (i, s) => {
        if (e && _(i.customFiltered, s, e))
          return i;
        if (/^[a-z]+$/.test(s)) {
          if (i.safeListed.includes(s))
            throw new Error(`You have this class in the safelist and as a class name.
                     Classes that are safe listed are not filtered just prepended
                     to the start result of this function.
                     If you want them filtered then please use a filter map instead.
                    `);
          return i.safeListed.push(s), i;
        }
        return a(i, s, e);
      };
    }
    function Ne(e) {
      return e instanceof Map;
    }
    function We(e) {
      return typeof e == "string";
    }
    var k = (e) => (...a) => {
      let { sortedClassesCreator: i, classMapChanger: s, classMapToStringTransformer: t, filterObject: r } = e, l = /\s+/, n = (0, Z.default)(...a).split(l);
      if (n.length < 2)
        throw new Error("This string has no sets of classes please add spaces between classes that need to be sorted");
      return Ee(i, s, t)(n, r);
    };
    var ke = k({ sortedClassesCreator: L, classMapChanger(e, a) {
      return Y(e.basicUtility, a) || Q(e.bem, a, e.safeListed), e;
    }, classMapToStringTransformer(e, a) {
      if (e.bem.size !== 0)
        for (let [i, s] of e.bem) {
          let t = s == null ? void 0 : s.get("modifier"), r = s == null ? void 0 : s.get("element");
          t && (a = a.concat(`${i} ${i}${t} `)), r && (a = a.concat(`${i}${r} `));
        }
      if (e.basicUtility.size !== 0)
        for (let [i, s] of e.basicUtility) {
          if (!s)
            continue;
          let r = [s.get("digit"), s.get("word"), s.get("color")].filter(We).map((l) => `${i}${l} `);
          a = a.concat(...r);
        }
      return a;
    } });
    var je = k({ sortedClassesCreator: q, classMapChanger(e, a, i) {
      if ([() => E(e.tailwindCSSUtility, a), () => N(e.arbitraryProperties, a), () => W(e.tailwindCSSUtility, a)].some((n) => n() === true))
        return e;
      let { customFiltered: t, tailwindCSSUtility: r, arbitraryProperties: l } = e;
      return X({ tailwindCSSUtility: r, arbitraryProperties: l, customFiltered: t }, a, i), e;
    }, classMapToStringTransformer(e, a) {
      if (e.arbitraryProperties.size !== 0) {
        for (let [i, s] of e.arbitraryProperties)
          if (!(!s || s.size === 0))
            for (let [r, l] of s)
              a = a.concat(`${r === "base" ? "" : r}[${i}${l}] `);
      }
      if (e.tailwindCSSUtility.size !== 0)
        for (let [i, s] of e.tailwindCSSUtility) {
          if (!s || s.size === 0)
            continue;
          let l = [s.get("digit"), s.get("word"), s.get("color"), s.get("function"), s.get("variable"), s.get("args")].filter(Ne).map((n) => {
            let o = n == null ? void 0 : n.get("prefix"), y = n == null ? void 0 : n.get("value");
            return `${i}${o}${y} `;
          });
          a = a.concat(...l);
        }
      return a;
    } });
    var De = k({ filterObject: { visibility: ["visible", "invisible", "collapse"], layout: ["d-flex", "grid"], stack: ["vstack", "hstack"] }, sortedClassesCreator: H, classMapChanger(e, a) {
      return J(e.bootstrapCSSUtility, a), e;
    }, classMapToStringTransformer(e, a) {
      if (e.bootstrapCSSUtility.size !== 0)
        for (let [i, s] of e.bootstrapCSSUtility) {
          if (!s)
            continue;
          let [t, r] = [s.get("digitMap"), s.get("wordMap")];
          if (t)
            for (let [l, n] of t.entries()) {
              let o = l === "base" ? "" : l;
              a = a.concat(`${i}-${n}${o} `);
            }
          if (r)
            for (let [l, n] of r.entries()) {
              let o = l === "base" ? "" : l;
              a = a.concat(`${i}-${n}${o} `);
            }
        }
      return a;
    } });
  }
});
export default require_dist();
//# sourceMappingURL=@code-fixer-23_cn-efs.js.map
