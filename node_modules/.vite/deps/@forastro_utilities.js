import "./chunk-Y2F7D3TJ.js";

// node_modules/.pnpm/@forastro+utilities@4.3.7_astro@4.0.3/node_modules/@forastro/utilities/dist/index.js
import { getCollection as T, getEntryBySlug as D, getEntry as G, getEntries as N } from "astro:content";
var u = class {
  constructor(t, n, o) {
    this.firstIterationNum = t;
    this.iterationNum = n;
    this.lastIterationNum = o;
  }
  get count() {
    return this.lastIterationNum - this.firstIterationNum;
  }
  get iteration() {
    return this.iterationNum + 1;
  }
  get isFirst() {
    return this.firstIterationNum === this.iterationNum;
  }
  get isLast() {
    return this.lastIterationNum === this.iteration;
  }
  get isEven() {
    return this.iterationNum % 2 === 0;
  }
  get isOdd() {
    return this.iterationNum % 2 !== 0;
  }
  get remaining() {
    return this.lastIterationNum - this.iteration;
  }
};
function* E(e) {
  let n = /* @__PURE__ */ new Map(), o = 0;
  e.forEach((r, a) => n.set(a, r));
  let s = n.size;
  for (let [r, a] of n)
    yield { value: a, info: new u(0, o, s), key: r }, o++;
}
var p = (e) => c(e) && (typeof e[Symbol.iterator] == "function" || typeof e[Symbol.asyncIterator] == "function");
function c(e) {
  return typeof e == "object" && e != null;
}
function g(e) {
  return p(e) && e.toString() === "[object Generator]";
}
function d(e) {
  return async function* (...t) {
    let n = e(...t);
    if (n instanceof Promise) {
      yield await n;
      return;
    }
    yield n;
  };
}
function b(e) {
  return c(e) && "forEach" in e;
}
function C(e, t) {
  if (e)
    return t();
}
function m(e, t, n) {
  function o(s) {
    let r = ["ifCb", "elseCb", "condition"];
    return c(s) && r.length === Object.keys(s).length && r.every((a) => a in s);
  }
  if (o(e) && !t && !n) {
    let { condition: s, ifCb: r, elseCb: a } = e;
    return s ? r() : a();
  }
  return e ? t == null ? void 0 : t() : n == null ? void 0 : n();
}
function B(e, t) {
  return C(!e, t);
}
function h(e, t = "Condition is false") {
  C(e, () => {
    throw new Error(t);
  });
}
function l(e, t = "Condition is true") {
  h(!e, t);
}
var Y = (e) => ({ transform(t) {
  return e(...Object.values(t));
} });
function* O(e, t, n = {}) {
  let { step: o = 1, inclusive: s } = n;
  if (h(e === t, "Start can't be the same as stop"), h(o <= 0, "Step can't be zero or a negative number"), e > t) {
    let r = e;
    if (s) {
      for (; r >= t; )
        yield r, r -= o;
      return;
    }
    for (; r > t; )
      yield r, r -= o;
    return;
  }
  if (e < t) {
    let r = e;
    if (s) {
      for (; r <= t; )
        yield r, r += o;
      return;
    }
    for (; r < t; )
      yield r, r += o;
  }
}
async function* w(e, t) {
  if (l(p(e), "You did not pass in an iterable"), b(e)) {
    for (let { value: n, info: o, key: s } of E(e))
      yield* d(t)(n, o, s);
    return;
  }
  if (g(e))
    for (let n of e)
      yield* d(t)(n);
}
function* $(e, t) {
  if (l(p(e), "You did not pass in an iterable"), b(e)) {
    for (let { value: n, info: o, key: s } of E(e))
      yield t(n, o, s);
    return;
  }
  if (g(e))
    for (let n of e)
      yield t(n);
}
async function* _(e, t) {
  let { start: n, stop: o, step: s = 1, inclusive: r } = t;
  yield* w(O(n, o, { step: s, inclusive: r }), (a) => e(a, new u(n, a, o)));
}
var I = (e) => Object.assign((t, n, o) => ({ ...t, [Symbol.toStringTag]: "AstroComponent", async *[Symbol.asyncIterator]() {
  yield* d(e)(n, o);
} }), { isAstroComponentFactory: true });
async function J(e) {
  try {
    return [await e, null];
  } catch (t) {
    return t instanceof Error ? [null, t] : typeof t == "string" ? [null, new Error(t)] : typeof t == "object" ? [null, new Error(JSON.stringify(t, null, 2))] : [null, new Error("Something went wrong")];
  }
}
var A = 0;
var P = (e) => {
  let t, n;
  A++;
  let o = I((r, a) => {
    l(typeof a.default == "function", `Please pass a Child into this component
            Templater${(e == null ? void 0 : e.toUpperCase()) ?? A} Invalid Child`), t = a.default;
    let f = c(r) && Object.keys(r).length > 0;
    f && (n = Object.freeze(r));
  }), s = I((r, a) => {
    var _a;
    let i = (_a = t == null ? void 0 : t()) == null ? void 0 : _a.expressions.at(0), y = c(r) && Object.keys(r).length > 0;
    return m(typeof i == "function", () => m(y, () => i(Object.freeze(r), m(n, () => () => a == null ? void 0 : a.default(n), () => a == null ? void 0 : a.default)), () => i(a.default)), t);
  });
  return [o, s];
};
var ot = async (e, t) => t ? (await Promise.all(e.map((n) => T(n, t)))).flat() : (await Promise.all(e.map((n) => T(n)))).flat();
var F = async (e, t) => (await T(e, t)).map((n) => ({ slug: n.slug, ...n.data }));
var R = async (e, t) => await F(e, x(t));
var U = async (e, t) => await F(e, M(t));
var at = Object.assign(F, { filterNonDrafts: R, filterDrafts: U });
var k = async (e, t) => {
  let n = await G(e, t);
  return "slug" in n ? { slug: n.slug, ...n.data } : n.data;
};
var S = async (e, t) => {
  let n = await D(e, t);
  return { slug: n.slug, ...n.data };
};
var st = Object.assign(k, { bySlug: S });
var it = async (e) => (await N(e)).map((t) => ({ slug: t.slug, ...t.data }));
var lt = async (e, t, n) => {
  let o = /* @__PURE__ */ new Map(), s = await T(e, x(n)), r = ["render", "body"];
  return s.map((a, f) => {
    if (f !== 0 && o.clear(), typeof t == "string") {
      if (r.includes(t))
        throw new Error(`Don't use these ${r.join(" ")} keys at all if you do the values from the entry will be used it will not come from the data.`);
      let i = t in a ? a[t] : t in a.data ? a.data[t] : null;
      l(typeof i == "string" || typeof i == "number", "You can only use strings and numbers as params"), o.set(t, i);
    }
    return Array.isArray(t) && t.forEach((i) => {
      if (typeof i == "string" && r.includes(i))
        throw new Error(`Don't use these ${r.join(" ")} keys at all if you do the values from the entry will be used it will not come from the data.`);
      let y = i in a ? a[i] : i in a.data ? a.data[i] : null;
      l(typeof y == "string" || typeof y == "number", "You can only use strings and numbers as params"), o.set(i, y);
    }), { params: Object.fromEntries(o), props: a };
  });
};
function M(e) {
  return function(t) {
    return "draft" in t.data || "draft" in t.data && t.data.draft === true || !!(e == null ? void 0 : e(t));
  };
}
function x(e) {
  return function(t) {
    return !("draft" in t.data) || "draft" in t.data && !t.data.draft || !!(e == null ? void 0 : e(t));
  };
}
export {
  u as IterationInfo,
  I as createAstroFunctionalComponent,
  Y as createMarkdocFunction,
  C as executeIf,
  m as executeIfElse,
  B as executeUnless,
  at as getCollectionDataList,
  lt as getCollectionPaths,
  ot as getCollections,
  it as getDataListFromEntries,
  st as getEntryData,
  w as iterate,
  _ as iterateRange,
  O as range,
  J as returnErrorAndResultFromPromise,
  $ as syncIterate,
  h as throwIf,
  l as throwUnless,
  P as useTemplaterAndProjector
};
/*! Bundled license information:

@forastro/utilities/dist/index.js:
  (*! Never return fom this function! *)
*/
//# sourceMappingURL=@forastro_utilities.js.map
